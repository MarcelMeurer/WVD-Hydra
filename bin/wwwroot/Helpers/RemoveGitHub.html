<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <title>Updating Hydra Instance</title>

    <style>
        * {
            transition: all 0.6s;
        }

        html {
            height: 100%;
        }

        body {
            font-family: 'Lato', sans-serif;
            color: #888;
            margin: 0;
        }

        #main {
            display: table;
            width: 100%;
            height: 100vh;
            text-align: center;
        }

        [hidden] {
            display: none !important;
        }

        .fof {
            display: table-cell;
            vertical-align: middle;
        }

            .fof h1,
            .fof button {
                font-size: 50px;
                display: inline-block;
                padding-right: 12px;
                animation: type .5s alternate infinite;
            }

        @keyframes type {
            from {
                box-shadow: inset -3px 0px 0px #888;
            }

            to {
                box-shadow: inset -3px 0px 0px transparent;
            }
        }
    </style>
</head>

<body>

<div id="main">
    <div class="fof">
        <div class="hydra-notice">
            <h1>Deployment configuration needs some changes</h1>
            <p>
                Your Hydra instance is currently connected to the Hydra GitHub repository.
                To switch to the new deployment method—which allows you to select specific versions—you must first disconnect the instance from GitHub.
            </p>

            <p>
                You can do this by clicking the button below. Please note that disconnecting will cause the instance to reboot.
            </p>

            <p>
                Before proceeding, make sure that no deployments, imaging processes, or automations are running, as this could result in orphaned resources.
            </p>

            <p>
                <strong>Note:</strong> After disconnecting from the GitHub repository, you will need to start the update process again.
            </p>
            <br/><br /><br />
        </div>
        <button id="updateBtn" hidden onclick="confirmUpdate()">Remove connection to GitHub</button>
        <h1 id="statusText">Initializing</h1>
        <p id="statusSubText"></p>
        <p><a href="/">Return</a></p>
    </div>
</div>

<script>


    const statusEl = document.getElementById("statusText");
    const statusElSub = document.getElementById("statusSubText");
    const updateBtn = document.getElementById("updateBtn");

    const params = new URLSearchParams(window.location.search);
    const version = params.get("version");


    const STATUS_URL = "/data/engine/updates/status";
    const READY_URL = "/Download/HydraMessageLogo.png";

    const POLL_INTERVAL = 5000;
    let phase = "INIT";

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function startUpdate() {
        try {
            statusEl.textContent = "Initializing";

            const response = await fetchWithTimeout("/data/engine/updates/removegithub", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: ""
            }, 1000);

            if (!response.ok) {
                let message = await response.text();
                console.log(response.status, message);
                if (response.status == 400) { throw new Error(message); }
            }

            console.log("Remove initialized");

            var retryCount = 120;
            while (retryCount > 0) {
                try {
                    const responseWaitForError = await fetchWithTimeout(READY_URL, null, 3000);

                    if (!responseWaitForError.ok) {
                        console.log("Expected error received:", response.status);
                        return response;
                    }

                } catch (err) {
                    console.log("Fetch failed:", err);
                    return;
                }
                retryCount--;
                await sleep(1000);
            }
            await sleep(3000);

        } catch (err) {
            statusEl.textContent = "Failed clean the GutHub connection";
            statusElSub.textContent = err;
            throw err;
        }
    };



    async function pollUpdateStatus() {
        switchToApplying();
    }


    function switchToApplying() {
        console.log("Current phase: ", phase);
        if (phase !== "INIT") return;

        console.log("Removing connection to GitHub is running");
        phase = "APPLYING";
        statusEl.textContent = "Removing connection";

        //clearInterval(statusInterval);
        readyInterval = setInterval(checkIfReady, POLL_INTERVAL);
    }


    async function checkIfReady() {
        try {
            const response = await fetch(READY_URL, {
                method: "GET",
                cache: "no-store"
            });

            if (response.ok) {
                finishUpdate();
            }
        } catch {

        }
    }

    function finishUpdate() {
        clearInterval(readyInterval);
        statusEl.textContent = "Connection is removed";

        setTimeout(() => {
            navigateBack();
        }, 10000);
    }

    function navigateBack() {
        const REENTER_URL = "/account/reenter";
        const FALLBACK_URL = "/Account/Signin";

        sessionStorage.clear();

        fetch(REENTER_URL, {
            method: "GET",
            cache: "no-store",
            redirect: "manual"
        })
            .then(response => {
                if (response.status >= 200 && response.status < 400) {
                    window.location.replace(REENTER_URL);
                    return;
                }
                if (response.status === 404 || response.status === 405) {
                    window.location.replace(FALLBACK_URL);
                    return;
                }
                if (response.status >= 500) {
                    window.location.replace(FALLBACK_URL);
                    return;
                }
                window.location.replace(FALLBACK_URL);
            })
            .catch(() => {
                window.location.replace(FALLBACK_URL);
            });
    }

    async function fetchWithTimeout(url, options = {}, timeout = 1000) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);

        try {
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            return response;
        } catch {
            return new Response("Accepted (mock)", {
                status: 202,
                statusText: "Accepted",
                headers: { "Content-Type": "text/plain" }
            });
        }
        finally {
            clearTimeout(id);
        }
    }

    async function init() {
        await startUpdate();
        const statusInterval = setInterval(pollUpdateStatus, POLL_INTERVAL);
        let readyInterval;
    };

    (async function Autostart() {
        statusElSub.textContent = "";
        statusEl.hidden = true;
        updateBtn.hidden = false;
    })();

    async function confirmUpdate() {
        statusElSub.textContent = "";
        statusEl.hidden = false;
        updateBtn.hidden = true;
        await init();
    }




</script>
</body>
</html>
